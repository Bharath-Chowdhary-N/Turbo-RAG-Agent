name: Cross-Repo Sync and Vector Update

on:
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      force_sync:
        description: 'Force full sync'
        required: false
        default: 'false'
      full_reprocess:
        description: 'Reprocess all vectors (not just changed files)'
        required: false
        default: 'false'
  
  # Triggered by repository_dispatch from the source repo
  repository_dispatch:
    types: [panstarrs_pipeline_update]
  
  # Optional: Schedule full reprocessing periodically
  schedule:
    - cron: '0 2 * * 0'  # Weekly on Sunday at 2 AM - full reprocess

env:
  SOURCE_REPO: 'patkel/turbo_telescope'  # Change to actual repo
  SOURCE_BRANCH: 'panstarrs_pipeline'
  DEST_DIR: 'data/github_repos'
  CHROMA_PERSIST_DIR: ./chroma_db
  PYTHON_VERSION: '3.10'

jobs:
  sync-and-process:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
    - name: Checkout this repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.PAT_TOKEN }}  # Personal Access Token with repo permissions
        lfs: true
        fetch-depth: 0
    
    - name: Checkout LFS objects
      run: git lfs pull
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install requests  # For API calls if needed
    
    - name: Clone source repository
      run: |
        echo "ðŸ“¥ Cloning source repository: ${{ env.SOURCE_REPO }}"
        git clone --depth 1 --branch ${{ env.SOURCE_BRANCH }} \
          https://${{ secrets.PAT_TOKEN }}@github.com/${{ env.SOURCE_REPO }}.git \
          /tmp/source_repo
    
    - name: Determine changed files
      id: changes
      run: |
        cd /tmp/source_repo
        
        # Check if this is a scheduled full reprocess
        if [[ "${{ github.event_name }}" == "schedule" ]] || [[ "${{ github.event.inputs.full_reprocess }}" == "true" ]]; then
          echo "ðŸ”„ Scheduled run or manual full reprocess requested"
          echo "sync_mode=full" >> $GITHUB_OUTPUT
          echo "process_mode=full" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
          # Get changed files from the webhook payload
          echo "Changed files from webhook:"
          echo '${{ toJson(github.event.client_payload) }}' | jq -r '.commits[].modified[]' > /tmp/changed_files.txt || true
          echo '${{ toJson(github.event.client_payload) }}' | jq -r '.commits[].added[]' >> /tmp/changed_files.txt || true
          echo '${{ toJson(github.event.client_payload) }}' | jq -r '.commits[].removed[]' >> /tmp/removed_files.txt || true
          
          cat /tmp/changed_files.txt
          
          if [ ! -s /tmp/changed_files.txt ]; then
            echo "No specific files detected, will sync all"
            echo "sync_mode=full" >> $GITHUB_OUTPUT
            echo "process_mode=full" >> $GITHUB_OUTPUT
          else
            echo "sync_mode=incremental" >> $GITHUB_OUTPUT
            echo "process_mode=incremental" >> $GITHUB_OUTPUT
          fi
        else
          echo "Manual trigger - incremental by default"
          echo "sync_mode=full" >> $GITHUB_OUTPUT
          echo "process_mode=incremental" >> $GITHUB_OUTPUT
        fi
    
    - name: Sync files to destination
      id: sync
      run: |
        SOURCE_PATH="/tmp/source_repo"
        DEST_PATH="${{ env.DEST_DIR }}"
        
        echo "ðŸ”„ Syncing files from $SOURCE_PATH to $DEST_PATH"
        
        # Create destination directory if it doesn't exist
        mkdir -p "$DEST_PATH"
        
        SYNC_MODE="${{ steps.changes.outputs.sync_mode }}"
        
        # Create a file list for vector processing
        rm -f /tmp/files_to_process.txt
        touch /tmp/files_to_process.txt
        
        if [[ "$SYNC_MODE" == "incremental" ]] && [[ -f /tmp/changed_files.txt ]]; then
          echo "ðŸ“ Incremental sync - copying only changed files"
          
          CHANGED_COUNT=0
          while IFS= read -r file; do
            if [ -n "$file" ] && [ -f "$SOURCE_PATH/$file" ]; then
              # Create directory structure
              mkdir -p "$DEST_PATH/$(dirname "$file")"
              
              # Copy file
              cp -f "$SOURCE_PATH/$file" "$DEST_PATH/$file"
              echo "âœ“ Synced: $file"
              
              # Add to processing list with full path
              echo "$DEST_PATH/$file" >> /tmp/files_to_process.txt
              
              ((CHANGED_COUNT++))
            fi
          done < /tmp/changed_files.txt
          
          # Handle removed files
          if [ -f /tmp/removed_files.txt ]; then
            while IFS= read -r file; do
              if [ -n "$file" ] && [ -f "$DEST_PATH/$file" ]; then
                echo "ðŸ—‘ï¸ Removing: $file"
                rm -f "$DEST_PATH/$file"
                # Note: Also need to remove from vector DB - handled by processor
                echo "REMOVED:$DEST_PATH/$file" >> /tmp/files_to_process.txt
              fi
            done < /tmp/removed_files.txt
          fi
          
          echo "files_changed=$CHANGED_COUNT" >> $GITHUB_OUTPUT
          echo "ðŸ“Š Synced $CHANGED_COUNT files"
        else
          echo "ðŸ“¦ Full sync - copying all files"
          
          # Use rsync for efficient sync
          rsync -av --delete \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='*.pyc' \
            --exclude='__pycache__' \
            "$SOURCE_PATH/" "$DEST_PATH/"
          
          CHANGED_COUNT=$(find "$DEST_PATH" -type f | wc -l)
          echo "files_changed=$CHANGED_COUNT" >> $GITHUB_OUTPUT
          echo "ðŸ“Š Synced all files (total: $CHANGED_COUNT)"
          
          # For full sync, we'll let the processor decide what to process
          echo "FULL_SYNC" > /tmp/files_to_process.txt
        fi
        
        # Show what will be processed
        echo "Files marked for vector processing:"
        cat /tmp/files_to_process.txt
    
    - name: Track with Git LFS
      run: |
        # Track large files with Git LFS
        cd ${{ env.DEST_DIR }}
        find . -type f -size +100M -exec git lfs track {} \; || true
        
        # Add common large file patterns
        git lfs track "*.fits" || true
        git lfs track "*.hdf5" || true
        git lfs track "*.h5" || true
        git lfs track "*.parquet" || true
        git lfs track "*.pkl" || true
    
    - name: Commit and push changes
      id: commit
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Force add files even if in .gitignore (since data dir might be ignored)
        git add -f ${{ env.DEST_DIR }}
        git add .gitattributes || true
        
        # Check if there are changes to commit
        if git diff --staged --quiet; then
          echo "No changes to commit"
          echo "has_changes=false" >> $GITHUB_OUTPUT
        else
          COMMIT_MSG="ðŸ”„ Sync from ${{ env.SOURCE_REPO }}@${{ env.SOURCE_BRANCH }}"
          
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            COMMIT_MSG="$COMMIT_MSG - Triggered by commit ${{ github.event.client_payload.after }}"
          fi
          
          git commit -m "$COMMIT_MSG"
          git push
          
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "âœ… Changes committed and pushed"
        fi
    
    - name: Process Vectors (Incremental - Changed Files Only)
      if: steps.commit.outputs.has_changes == 'true' && steps.changes.outputs.process_mode == 'incremental'
      run: |
        echo "ðŸŽ¯ INCREMENTAL processing - only changed files"
        
        if [ -f /tmp/files_to_process.txt ] && [ -s /tmp/files_to_process.txt ]; then
          FILE_COUNT=$(wc -l < /tmp/files_to_process.txt)
          echo "Processing $FILE_COUNT changed file(s)"
          
          # Pass the file list to the processor
          python ci_vector_processor.py \
            --data-dir ./data \
            --file-list /tmp/files_to_process.txt \
            --incremental
        else
          echo "No files to process"
        fi
      timeout-minutes: 15
    
    - name: Process Vectors (Full - All Files)
      if: steps.commit.outputs.has_changes == 'true' && steps.changes.outputs.process_mode == 'full'
      run: |
        echo "ðŸš€ FULL processing - all files in data directory"
        python ci_vector_processor.py --data-dir ./data
      timeout-minutes: 120
    
    - name: Validate Processing Results
      if: steps.commit.outputs.has_changes == 'true'
      run: |
        if [ -f "processing_results.json" ]; then
          echo "âœ… Processing completed successfully!"
          cat processing_results.json | python -m json.tool
        else
          echo "âŒ No processing results file found!"
          exit 1
        fi
    
    - name: Upload Processing Results
      if: steps.commit.outputs.has_changes == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: sync-processing-results-${{ github.run_number }}
        path: |
          processing_results.json
          /tmp/files_to_process.txt
          /tmp/changed_files.txt
    
    - name: Slack Notification
      if: always()
      uses: rtCamp/action-slack-notify@v2
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
        SLACK_TITLE: 'Cross-Repo Sync Status'
        SLACK_MESSAGE: |
          Status: ${{ job.status == 'success' && 'âœ… Success' || 'âŒ Failed' }}
          Source: ${{ env.SOURCE_REPO }}@${{ env.SOURCE_BRANCH }}
          Sync Mode: ${{ steps.changes.outputs.sync_mode }}
          Process Mode: ${{ steps.changes.outputs.process_mode }}
          Files Changed: ${{ steps.sync.outputs.files_changed }}
          Vector Processing: ${{ steps.commit.outputs.has_changes == 'true' && 'Completed' || 'Skipped (no changes)' }}
          Trigger: ${{ github.event_name }}
        SLACK_COLOR: ${{ job.status == 'success' && 'good' || 'danger' }}
